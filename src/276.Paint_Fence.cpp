class Solution {
public:
    int numWays(int n, int k) {
        if (n == 0)
            return 0;
        int same = 0, diff = k; //实际上d[i]只依赖于最后的d[i - 1]与d[i - 2]两个变量
        for(int i = 2; i <= n; i++) {
            int tmp = diff;
            diff = diff*(k - 1) + same*(k - 1); //same相当于之前的d[i - 2], diff相当于之前的d[i - 1]
            same = tmp;//前进一步，最新计算的变成了最新的diff
        }
        return same + diff;
    }
};

//假设3种颜色，算到i时候，i可以取与i-1不同的颜色，那么就是d[i - 1]*(k - 1)
//假设i与i-1取了相同的颜色，那么这个颜色必定是与d[i - 2]不管最后一个颜色是什么的颜色不同的一个颜色，k-1种

///////////////////////////////////////////////////////////
class Solution {
public:
    int numWays(int n, int k) {
        if (n == 0)
            return 0;
        if (n == 1)
            return k;
        if (n == 2)
            return k * k;
        int d[n + 1] = {0};
        d[0] = 0;
        d[1] = k;
        d[2] = k*k;
        for(int i = 3; i <= n; i++)
            d[i] = d[i - 1]*(k - 1) + d[i - 2]*(k - 1);
        
        return d[n];
    }
};
/*
diff的部分，之前一共有多少种刷法(s)，最后一个的颜色为k中的一个，那么下一个颜色要不一样，就必须是 k - 1中的一个，s*k
same的部分，就是看之前diff的刷法一共是多少种（不可以是same的，因为如果这样继续刷一样就变成3个连在一起），如果最后diff刷红色，这个也刷红色即可，不变
当n=2时，k=2时，我们可以分两种情况来统计，一种是相邻部分没有相同的，一种相同部分有相同的颜色，那么对于没有相同的，对于第一个格子，我们有k种填法，对于下一个相邻的格子，由于不能相同，所以我们只有k-1种填法。而有相同部分颜色的刷法和上一个格子的不同颜色刷法相同，因为我们下一格的颜色和之前那个格子颜色刷成一样的即可，最后总共的刷法就是把不同和相同两个刷法加起来
*/
